'use server';

import { prisma } from "@/lib/prisma";
import { transactionWizardSchema, TransactionWizardValues } from "@/lib/schemas/transaction-wizard";
import { TRANSACTION_TYPES } from "@/lib/config/transaction-types";
import { AccountingService } from "@/services/accounting-service";
import { ReferenceType, JournalStatus } from "@prisma/client";
import { requireAuth } from "@/lib/auth-checks";
import { revalidatePath } from "next/cache";

export async function createWizardTransaction(data: TransactionWizardValues) {
    const session = await requireAuth();

    // 1. Validate Input
    const validation = transactionWizardSchema.safeParse(data);
    if (!validation.success) {
        return { success: false, error: validation.error.issues[0].message };
    }

    // 2. Find Config
    const config = TRANSACTION_TYPES.find(t => t.id === data.transactionTypeId);
    if (!config) {
        return { success: false, error: "Invalid transaction type" };
    }

    try {
        // 3. Resolve Account IDs
        const debitAccountId = data.customDebitAccountId || (await getAccountIdByCode(config.debitAccountCode));
        const creditAccountId = data.customCreditAccountId || (await getAccountIdByCode(config.creditAccountCode));

        // 4. Create Journal Entry
        // Use ReferenceType based on category
        let referenceType = ReferenceType.MANUAL_ENTRY as ReferenceType;
        if (config.category === 'PURCHASE') referenceType = ReferenceType.GOODS_RECEIPT as ReferenceType;
        if (config.category === 'SALES') referenceType = ReferenceType.SALES_INVOICE as ReferenceType;

        const result = await AccountingService.createJournalEntry({
            entryDate: data.entryDate,
            description: data.description,
            reference: data.reference ?? "",
            referenceType,
            createdById: session.user.id,
            isAutoGenerated: false,
            // Simple mode always posts directly to make it easy for non-accountants
            status: JournalStatus.POSTED,
            lines: [
                {
                    accountId: debitAccountId,
                    debit: data.amount,
                    credit: 0,
                    description: data.description
                },
                {
                    accountId: creditAccountId,
                    debit: 0,
                    credit: data.amount,
                    description: data.description
                }
            ]
        });

        revalidatePath('/finance/journals');
        revalidatePath('/finance/reports/balance-sheet');
        revalidatePath('/finance/reports/trial-balance');
        revalidatePath('/finance');

        return { success: true, id: result.id };
    } catch (error) {
        console.error("Wizard Transaction Error:", error);
        return { success: false, error: error instanceof Error ? error.message : "Failed to record transaction" };
    }
}

const accountCache = new Map<string, string>();

async function getAccountIdByCode(code: string): Promise<string> {
    if (accountCache.has(code)) return accountCache.get(code)!;

    const acc = await prisma.account.findUnique({ where: { code } });
    if (!acc) throw new Error(`GL Account code ${code} not found. Please contact Administrator to fix COA.`);

    accountCache.set(code, acc.id);
    return acc.id;
}
