'use server';

import { prisma } from "@/lib/prisma";
import { transactionWizardSchema, TransactionWizardValues } from "@/lib/schemas/transaction-wizard";
import { TRANSACTION_TYPES } from "@/lib/config/transaction-types";
import { AccountingService } from "@/services/accounting-service";
import { FixedAssetService } from "@/services/finance/fixed-asset-service";
import { ReferenceType, JournalStatus } from "@prisma/client";
import { requireAuth } from "@/lib/auth-checks";
import { revalidatePath } from "next/cache";
import { recordCustomerPayment, recordSupplierPayment } from "./finance";

export async function createWizardTransaction(data: TransactionWizardValues) {
    const session = await requireAuth();

    // 1. Validate Input
    const validation = transactionWizardSchema.safeParse(data);
    if (!validation.success) {
        return { success: false, error: validation.error.issues[0].message };
    }

    // 2. Find Config
    const config = TRANSACTION_TYPES.find(t => t.id === data.transactionTypeId);
    if (!config) {
        return { success: false, error: "Invalid transaction type" };
    }

    try {
        // 3. Delegate to specialized actions if it's an invoice payment
        if (config.requiresInvoice && data.invoiceId) {
            // Determine payment method from custom accounts if possible, or use default
            const targetAccountId = config.requiresInvoice === 'SALES' ? data.customDebitAccountId : data.customCreditAccountId;

            let bankAcc;
            if (targetAccountId) {
                bankAcc = await prisma.account.findUnique({ where: { id: targetAccountId } });
            } else {
                bankAcc = await prisma.account.findUnique({ where: { code: config.requiresInvoice === 'SALES' ? config.debitAccountCode : config.creditAccountCode } });
            }

            const method = bankAcc?.code === '11110' ? 'Cash' : 'Bank Transfer';

            if (config.requiresInvoice === 'SALES') {
                const result = await recordCustomerPayment({
                    invoiceId: data.invoiceId,
                    amount: data.amount,
                    paymentDate: data.entryDate,
                    method,
                    notes: data.description
                });
                if (!result.success) return { success: false, error: result.error };
                return { success: true };
            } else {
                const result = await recordSupplierPayment({
                    invoiceId: data.invoiceId,
                    amount: data.amount,
                    paymentDate: data.entryDate,
                    method,
                    notes: data.description
                });
                if (!result.success) return { success: false, error: result.error };
                return { success: true };
            }
        }

        // 4. Resolve Account IDs
        const debitAccountId = data.customDebitAccountId || (await getAccountIdByCode(config.debitAccountCode));
        const creditAccountId = data.customCreditAccountId || (await getAccountIdByCode(config.creditAccountCode));

        // 5. Create Journal Entry
        // Use ReferenceType based on category
        let referenceType = ReferenceType.MANUAL_ENTRY as ReferenceType;
        if (config.category === 'ASSET') referenceType = ReferenceType.GOODS_RECEIPT as ReferenceType;
        if (config.category === 'SALES') referenceType = ReferenceType.SALES_INVOICE as ReferenceType;

        const result = await AccountingService.createJournalEntry({
            entryDate: data.entryDate,
            description: data.description,
            reference: data.reference ?? "",
            referenceType,
            createdById: session.user.id,
            isAutoGenerated: false,
            // Simple mode always posts directly to make it easy for non-accountants
            status: JournalStatus.POSTED,
            lines: [
                {
                    accountId: debitAccountId,
                    debit: data.amount,
                    credit: 0,
                    description: data.description
                },
                {
                    accountId: creditAccountId,
                    debit: 0,
                    credit: data.amount,
                    description: data.description
                }
            ]
        });

        // 6. If it's an asset, register it in Fixed Asset module
        if (config.category === 'ASSET' && data.assetCode) {
            await FixedAssetService.createAsset({
                assetCode: data.assetCode,
                name: data.description, // Use general description as name if not separate
                category: config.label,
                purchaseDate: data.entryDate,
                purchaseValue: data.amount,
                usefulLifeMonths: data.usefulLifeMonths || 48, // Default to 4 years if missing
                assetAccountId: debitAccountId,
                depreciationAccountId: data.depreciationAccountId || "",
                accumulatedDepreciationAccountId: data.accumulatedDepreciationAccountId || ""
            });
            revalidatePath('/finance/assets');
        }

        revalidatePath('/finance/journals');
        revalidatePath('/finance/reports/balance-sheet');
        revalidatePath('/finance/reports/trial-balance');
        revalidatePath('/finance');

        return { success: true, id: result.id };
    } catch (error) {
        console.error("Wizard Transaction Error:", error);
        return { success: false, error: error instanceof Error ? error.message : "Failed to record transaction" };
    }
}

const accountCache = new Map<string, string>();

async function getAccountIdByCode(code: string): Promise<string> {
    if (accountCache.has(code)) return accountCache.get(code)!;

    const acc = await prisma.account.findUnique({ where: { code } });
    if (!acc) throw new Error(`GL Account code ${code} not found. Please contact Administrator to fix COA.`);

    accountCache.set(code, acc.id);
    return acc.id;
}
