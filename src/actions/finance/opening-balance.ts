'use server';

import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/auth-checks';
import { AccountingService } from '@/services/accounting-service';
import { InvoiceStatus, PurchaseInvoiceStatus, ReferenceType, AccountType, AccountCategory, SalesOrderType, SalesOrderStatus, PurchaseOrderStatus } from '@prisma/client';
import { serializeData } from '@/lib/utils';
import { revalidatePath } from 'next/cache';

const OPENING_BALANCE_ACCOUNT_CODE = '30000';
const AR_ACCOUNT_CODE = '11210';
const AP_ACCOUNT_CODE = '21110';

interface CreateOpeningBalanceInput {
    type: 'AR' | 'AP'; // AR = Piutang (Customer), AP = Hutang (Supplier)
    entityId: string; // CustomerId or SupplierId
    invoiceNumber: string;
    date: Date;
    dueDate: Date;
    amount: number;
    notes?: string;
}

export async function createOpeningBalance(data: CreateOpeningBalanceInput) {
    const session = await requireAuth();

    try {
        // 1. Ensure "Opening Balance Equity" account exists
        let equityAccount = await prisma.account.findUnique({ where: { code: OPENING_BALANCE_ACCOUNT_CODE } });
        if (!equityAccount) {
            equityAccount = await prisma.account.create({
                data: {
                    code: OPENING_BALANCE_ACCOUNT_CODE,
                    name: 'Opening Balance Equity',
                    type: AccountType.EQUITY,
                    category: AccountCategory.CAPITAL,
                    description: 'System account for initial balance setup'
                }
            });
        }

        // 2. Get AR/AP Account
        const subLedgerAccountCode = data.type === 'AR' ? AR_ACCOUNT_CODE : AP_ACCOUNT_CODE;
        const subLedgerAccount = await prisma.account.findUnique({ where: { code: subLedgerAccountCode } });
        if (!subLedgerAccount) throw new Error(`Sub-ledger account ${subLedgerAccountCode} not found.`);

        // 3. Create Record
        let invoiceId = '';
        if (data.type === 'AR') {
            const res = await createAROpeningBalance(data, session.user.id, equityAccount.id, subLedgerAccount.id);
            invoiceId = res.id;
        } else {
            const res = await createAPOpeningBalance(data, session.user.id, equityAccount.id, subLedgerAccount.id);
            invoiceId = res.id;
        }

        // 4. Auto-Post the Journal Entry
        // This ensures opening balances reflect on the Balance Sheet immediately.
        // We find the journal entry associated with this invoice
        const journal = await prisma.journalEntry.findFirst({
            where: {
                referenceId: invoiceId,
                isAutoGenerated: true,
                status: 'DRAFT'
            }
        });

        if (journal) {
            await AccountingService.postJournal(journal.id, session.user.id);
        }

        revalidatePath('/finance');
        revalidatePath('/finance/reports/balance-sheet');
        return { success: true };
    } catch (error) {
        console.error('Opening Balance Error:', error);
        return { success: false, error: error instanceof Error ? error.message : 'Failed to create opening balance' };
    }
}

async function createAROpeningBalance(data: CreateOpeningBalanceInput, userId: string, equityAccountId: string, arAccountId: string) {
    // 3a. Create Dummy Sales Order (Use transaction to ensure atomicity if needed, but keeping simple for now)
    const salesOrder = await prisma.salesOrder.create({
        data: {
            orderNumber: `SO-OPEN-${data.invoiceNumber}`,
            customerId: data.entityId,
            orderDate: data.date,
            status: SalesOrderStatus.DELIVERED, // Mark as delivered so it doesn't show up in pending lists
            orderType: SalesOrderType.MAKE_TO_STOCK, // Generic
            totalAmount: data.amount,
            notes: 'Opening Balance Entry',
            createdById: userId,
            // Create a dummy item to satisfy constraints if necessary, or leave empty if schema allows
            // items: { create: [] } 
        }
    });

    // 3b. Create Invoice
    const invoice = await prisma.invoice.create({
        data: {
            invoiceNumber: data.invoiceNumber, // Keep original external invoice number
            salesOrderId: salesOrder.id,
            invoiceDate: data.date,
            dueDate: data.dueDate,
            status: InvoiceStatus.UNPAID,
            totalAmount: data.amount,
            notes: data.notes || 'Opening Balance Transfer',
            termOfPaymentDays: 0, // already calculated manually
        }
    });

    // 3c. Create Journal Entry (Override Auto-Journal)
    // Dr AR, Cr Opening Balance Equity
    await AccountingService.createJournalEntry({
        entryDate: data.date,
        description: `Opening Balance AR - Inv #${data.invoiceNumber}`,
        reference: data.invoiceNumber,
        referenceType: ReferenceType.SALES_INVOICE,
        referenceId: invoice.id,
        isAutoGenerated: true, // System generated but manual logic
        createdById: userId,
        lines: [
            {
                accountId: arAccountId,
                debit: data.amount,
                credit: 0,
                description: `Opening Balance Receivable`
            },
            {
                accountId: equityAccountId,
                debit: 0,
                credit: data.amount,
                description: `Opening Equity Offset`
            }
        ]
    });

    return invoice;
}

async function createAPOpeningBalance(data: CreateOpeningBalanceInput, userId: string, equityAccountId: string, apAccountId: string) {
    // 3a. Create Dummy Purchase Order
    const purchaseOrder = await prisma.purchaseOrder.create({
        data: {
            orderNumber: `PO-OPEN-${data.invoiceNumber}`,
            supplierId: data.entityId,
            orderDate: data.date,
            status: PurchaseOrderStatus.RECEIVED,
            totalAmount: data.amount,
            notes: 'Opening Balance Entry',
            createdById: userId,
        }
    });

    // 3b. Create Purchase Invoice
    const invoice = await prisma.purchaseInvoice.create({
        data: {
            invoiceNumber: data.invoiceNumber,
            purchaseOrderId: purchaseOrder.id,
            invoiceDate: data.date,
            dueDate: data.dueDate,
            status: PurchaseInvoiceStatus.UNPAID,
            totalAmount: data.amount,
            notes: data.notes || 'Opening Balance Transfer',
        }
    });

    // 3c. Create Journal Entry
    // Dr Opening Balance Equity, Cr AP
    await AccountingService.createJournalEntry({
        entryDate: data.date,
        description: `Opening Balance AP - Inv #${data.invoiceNumber}`,
        reference: data.invoiceNumber,
        referenceType: ReferenceType.PURCHASE_INVOICE,
        referenceId: invoice.id,
        isAutoGenerated: true,
        createdById: userId,
        lines: [
            {
                accountId: equityAccountId,
                debit: data.amount,
                credit: 0,
                description: `Opening Equity Offset`
            },
            {
                accountId: apAccountId,
                debit: 0,
                credit: data.amount,
                description: `Opening Balance Payable`
            }
        ]
    });

    return invoice;
}

export async function getRecentOpeningBalances() {
    await requireAuth();

    try {
        const [arInvoices, apInvoices] = await Promise.all([
            prisma.invoice.findMany({
                where: {
                    salesOrder: {
                        orderNumber: { startsWith: 'SO-OPEN-' }
                    }
                },
                include: {
                    salesOrder: {
                        include: { customer: { select: { name: true } } }
                    }
                },
                orderBy: { createdAt: 'desc' },
                take: 10
            }),
            prisma.purchaseInvoice.findMany({
                where: {
                    purchaseOrder: {
                        orderNumber: { startsWith: 'PO-OPEN-' }
                    }
                },
                include: {
                    purchaseOrder: {
                        include: { supplier: { select: { name: true } } }
                    }
                },
                orderBy: { createdAt: 'desc' },
                take: 10
            })
        ]);

        const history = [
            ...arInvoices.map(inv => ({
                id: inv.id,
                type: 'AR' as const,
                invoiceNumber: inv.invoiceNumber,
                entityName: inv.salesOrder?.customer?.name || 'Unknown',
                date: inv.invoiceDate,
                amount: Number(inv.totalAmount),
                createdAt: inv.createdAt
            })),
            ...apInvoices.map(inv => ({
                id: inv.id,
                type: 'AP' as const,
                invoiceNumber: inv.invoiceNumber,
                entityName: inv.purchaseOrder?.supplier?.name || 'Unknown',
                date: inv.invoiceDate,
                amount: Number(inv.totalAmount),
                createdAt: inv.createdAt
            }))
        ].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

        return { success: true, data: serializeData(history) };
    } catch (error) {
        console.error('Failed to fetch opening balance history:', error);
        return { success: false, error: 'Failed to fetch history' };
    }
}

export async function deleteOpeningBalance(id: string, type: 'AR' | 'AP') {
    await requireAuth();

    try {
        await prisma.$transaction(async (tx) => {
            if (type === 'AR') {
                const invoice = await tx.invoice.findUnique({
                    where: { id },
                    include: { salesOrder: true }
                });

                if (!invoice) throw new Error("Invoice not found");

                // Delete associated Journal Entries
                await tx.journalLine.deleteMany({
                    where: { journalEntry: { referenceId: invoice.id, referenceType: ReferenceType.SALES_INVOICE } }
                });
                await tx.journalEntry.deleteMany({
                    where: { referenceId: invoice.id, referenceType: ReferenceType.SALES_INVOICE }
                });

                // Delete Invoice
                await tx.invoice.delete({ where: { id } });

                // Delete Sales Order
                if (invoice.salesOrder) {
                    await tx.salesOrder.delete({ where: { id: invoice.salesOrderId } });
                }
            } else {
                const invoice = await tx.purchaseInvoice.findUnique({
                    where: { id },
                    include: { purchaseOrder: true }
                });

                if (!invoice) throw new Error("Purchase invoice not found");

                // Delete associated Journal Entries
                await tx.journalLine.deleteMany({
                    where: { journalEntry: { referenceId: invoice.id, referenceType: ReferenceType.PURCHASE_INVOICE } }
                });
                await tx.journalEntry.deleteMany({
                    where: { referenceId: invoice.id, referenceType: ReferenceType.PURCHASE_INVOICE }
                });

                // Delete Invoice
                await tx.purchaseInvoice.delete({ where: { id } });

                // Delete Purchase Order
                if (invoice.purchaseOrder) {
                    await tx.purchaseOrder.delete({ where: { id: invoice.purchaseOrderId } });
                }
            }
        });

        revalidatePath('/finance');
        revalidatePath('/finance/reports/balance-sheet');
        return { success: true };
    } catch (error) {
        console.error('Failed to delete opening balance:', error);
        return { success: false, error: error instanceof Error ? error.message : 'Deletion failed' };
    }
}
