import { prisma } from '@/lib/prisma';
import {
    AccountType,
    AccountCategory,
    JournalStatus,
    ReferenceType
} from '@prisma/client';

export type CreateJournalEntryInput = {
    entryDate: Date;
    description: string;
    reference: string;
    referenceType?: ReferenceType;
    referenceId?: string;
    lines: {
        accountId: string;
        debit: number;
        credit: number;
        description?: string;
    }[];
    createdById?: string;
    isAutoGenerated?: boolean;
};

export class AccountingService {

    /**
     * Create a new Journal Entry.
     * Default Status: DRAFT
     */
    static async createJournalEntry(input: CreateJournalEntryInput) {
        const { lines } = input;

        // Validate Balance
        const totalDebit = lines.reduce((sum, line) => sum + Number(line.debit), 0);
        const totalCredit = lines.reduce((sum, line) => sum + Number(line.credit), 0);

        if (Math.abs(totalDebit - totalCredit) > 0.01) {
            throw new Error(`Journal Entry is not balanced.Debit: ${totalDebit}, Credit: ${totalCredit} `);
        }

        // Period Check
        const isOpen = await this.isPeriodOpen(input.entryDate);
        if (!isOpen) {
            throw new Error("Cannot create journal entry in a closed fiscal period.");
        }

        return await prisma.journalEntry.create({
            data: {
                entryNumber: await this.generateEntryNumber(input.entryDate),
                entryDate: input.entryDate,
                description: input.description,
                reference: input.reference,
                referenceType: input.referenceType,
                referenceId: input.referenceId,
                status: JournalStatus.DRAFT,
                isAutoGenerated: input.isAutoGenerated || false,
                createdById: input.createdById,
                lines: {
                    create: lines.map(line => ({
                        accountId: line.accountId,
                        debit: line.debit,
                        credit: line.credit,
                        description: line.description
                    }))
                }
            },
            include: {
                lines: {
                    include: { account: true }
                }
            }
        });
    }

    /**
     * Post a Journal Entry (DRAFT -> POSTED)
     */
    static async postJournal(id: string, userId?: string) {
        const journal = await prisma.journalEntry.findUnique({
            where: { id },
            include: { lines: true }
        });

        if (!journal) throw new Error("Journal not found");
        if (journal.status !== 'DRAFT') throw new Error("Only DRAFT journals can be posted");

        // Period Check
        const isOpen = await this.isPeriodOpen(journal.entryDate);
        if (!isOpen) {
            throw new Error("Cannot post journal entry to a closed fiscal period.");
        }

        return await prisma.journalEntry.update({
            where: { id },
            data: {
                status: 'POSTED',
                approvedById: userId,
                approvedAt: new Date()
            }
        });
    }

    /**
     * Void a Journal Entry (POSTED -> VOIDED)
     */
    static async voidJournal(id: string, _userId?: string) {
        const journal = await prisma.journalEntry.findUnique({
            where: { id }
        });

        if (!journal) throw new Error("Journal not found");
        if (journal.status !== 'POSTED') throw new Error("Only POSTED journals can be voided");

        // Ideally check if period is closed before voiding.
        // For MVP, we allow voiding but it should be audited.

        return await prisma.journalEntry.update({
            where: { id },
            data: {
                status: 'VOIDED'
            }
        });
    }

    /**
     * Reverse a Journal Entry
     * Creates a new JE with swapped Debit/Credit
     */
    static async reverseJournal(id: string, userId?: string) {
        const original = await prisma.journalEntry.findUnique({
            where: { id },
            include: { lines: true }
        });

        if (!original) throw new Error("Journal not found");
        if (original.status !== 'POSTED') throw new Error("Only POSTED journals can be reversed");

        // Create Reversal
        const reversalLines = original.lines.map(l => ({
            accountId: l.accountId,
            debit: Number(l.credit),  // Swap
            credit: Number(l.debit),  // Swap
            description: `Reversal of ${original.entryNumber}: ${l.description || ''} `
        }));

        return await this.createJournalEntry({
            entryDate: new Date(), // Reversal date is today
            description: `Reversal of ${original.description} `,
            reference: original.entryNumber,
            referenceType: 'MANUAL_ENTRY', // Or separate REVERSAL type if exists
            createdById: userId,
            lines: reversalLines
        });
    }

    private static async generateEntryNumber(date: Date): Promise<string> {
        const year = date.getFullYear();
        const startOfYear = new Date(year, 0, 1);
        const endOfYear = new Date(year, 11, 31, 23, 59, 59);

        const count = await prisma.journalEntry.count({
            where: {
                entryDate: {
                    gte: startOfYear,
                    lte: endOfYear
                }
            }
        });

        const sequence = (count + 1).toString().padStart(5, '0');
        return `JE - ${year} -${sequence} `;
    }

    static async createBulkJournalEntries(data: CreateJournalEntryInput[]) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return await prisma.$transaction(async (tx: any) => {
            const results = [];
            for (const entry of data) {
                // Balance Check
                const totalDebit = entry.lines.reduce((sum, l) => sum + (Number(l.debit) || 0), 0);
                const totalCredit = entry.lines.reduce((sum, l) => sum + (Number(l.credit) || 0), 0);
                if (Math.abs(totalDebit - totalCredit) > 0.01) {
                    throw new Error(`Unbalanced journal for reference ${entry.reference}`);
                }

                // Generate Number (Simplified for Bulk)
                const entryYear = new Date(entry.entryDate).getFullYear();
                const count = await tx.journalEntry.count({
                    where: { entryDate: { gte: new Date(entryYear, 0, 1), lt: new Date(entryYear + 1, 0, 1) } }
                });
                const entryNumber: string = `JE - ${entryYear} -${(count + 1 + results.length).toString().padStart(5, '0')} `;

                const je = await tx.journalEntry.create({
                    data: {
                        entryNumber,
                        entryDate: entry.entryDate,
                        description: entry.description,
                        reference: entry.reference,
                        referenceType: entry.referenceType,
                        createdById: entry.createdById,
                        isAutoGenerated: entry.isAutoGenerated,
                        status: JournalStatus.DRAFT, // Default Draft for Bulk too
                        lines: {
                            create: entry.lines.map(l => ({
                                accountId: l.accountId,
                                debit: l.debit,
                                credit: l.credit,
                                description: l.description,
                                currency: 'IDR',
                                exchangeRate: 1
                            }))
                        }
                    }
                });
                results.push(je);
            }
            return results;
        });
    }

    static async getJournals(params?: { startDate?: Date, endDate?: Date, status?: JournalStatus, reference?: string }) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const where: any = {};

        if (params?.startDate && params?.endDate) {
            where.entryDate = { gte: params.startDate, lte: params.endDate };
        }
        if (params?.status) {
            where.status = params.status;
        }
        if (params?.reference) {
            where.reference = { contains: params.reference, mode: 'insensitive' };
        }

        return await prisma.journalEntry.findMany({
            where,
            include: {
                createdBy: { select: { name: true } },
                lines: true
            },
            orderBy: { entryDate: 'desc' }
        });
    }

    static async getJournalById(id: string) {
        return await prisma.journalEntry.findUnique({
            where: { id },
            include: {
                lines: {
                    include: { account: true }
                },
                createdBy: { select: { name: true } },
                approvedBy: { select: { name: true } }
            }
        });
    }

    static async getChartOfAccounts() {
        return await prisma.account.findMany({
            orderBy: { code: 'asc' }
        });
    }

    static async createAccount(data: { code: string; name: string; type: AccountType; category: AccountCategory; description?: string }) {
        const existing = await prisma.account.findUnique({ where: { code: data.code } });
        if (existing) throw new Error(`Account code ${data.code} already exists`);

        return await prisma.account.create({ data });
    }

    static async updateAccount(id: string, data: { code?: string; name?: string; type?: AccountType; category?: AccountCategory; description?: string }) {
        if (data.code) {
            const existing = await prisma.account.findUnique({ where: { code: data.code } });
            if (existing && existing.id !== id) throw new Error(`Account code ${data.code} already exists`);
        }

        return await prisma.account.update({
            where: { id },
            data
        });
    }

    static async deleteAccount(id: string) {
        const hasLines = await prisma.journalLine.findFirst({
            where: { accountId: id }
        });

        if (hasLines) {
            throw new Error("Cannot delete account because it has existing transactions. Consider deactivating it instead.");
        }

        return await prisma.account.delete({
            where: { id }
        });
    }

    /**
     * Get Trial Balance (POSTED ONLY)
     */
    static async getTrialBalance(startDate?: Date, endDate?: Date) {
        const accounts = await prisma.account.findMany({
            orderBy: { code: 'asc' }
        });

        // Only include POSTED journals
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const where: any = {
            journalEntry: {
                status: 'POSTED'
            }
        };

        if (endDate) {
            where.journalEntry.entryDate = { lte: endDate };
        }

        const balances = await prisma.journalLine.groupBy({
            by: ['accountId'],
            _sum: {
                debit: true,
                credit: true
            },
            where
        });

        const result = accounts.map(acc => {
            const agg = balances.find(b => b.accountId === acc.id);
            const totalDebit = Number(agg?._sum.debit || 0);
            const totalCredit = Number(agg?._sum.credit || 0);

            let netBalance = 0;
            if (['ASSET', 'EXPENSE'].includes(acc.type)) {
                netBalance = totalDebit - totalCredit;
            } else {
                netBalance = totalCredit - totalDebit;
            }

            return {
                ...acc,
                totalDebit,
                totalCredit,
                netBalance
            };
        });

        return result;
    }

    /**
     * Get Income Statement (POSTED ONLY)
     */
    static async getIncomeStatement(startDate: Date, endDate: Date) {
        const accounts = await prisma.account.findMany({
            where: {
                type: { in: ['REVENUE', 'EXPENSE'] }
            },
            include: {
                journalLines: {
                    where: {
                        journalEntry: {
                            entryDate: { gte: startDate, lte: endDate },
                            status: 'POSTED' // Only Posted
                        }
                    }
                }
            }
        });

        const revenues = accounts.filter(a => a.type === 'REVENUE').map(a => ({
            ...a,
            amount: a.journalLines.reduce((sum, l) => sum + (Number(l.credit) - Number(l.debit)), 0)
        }));

        const expenses = accounts.filter(a => a.type === 'EXPENSE').map(a => ({
            ...a,
            amount: a.journalLines.reduce((sum, l) => sum + (Number(l.debit) - Number(l.credit)), 0)
        }));

        const totalRevenue = revenues.reduce((sum, a) => sum + a.amount, 0);
        const totalExpense = expenses.reduce((sum, a) => sum + a.amount, 0);

        return {
            revenues,
            expenses,
            totalRevenue,
            totalExpense,
            netIncome: totalRevenue - totalExpense
        };
    }

    /**
     * Get Balance Sheet (POSTED ONLY)
     */
    static async getBalanceSheet(asOfDate: Date) {
        const accounts = await prisma.account.findMany({
            where: {
                type: { in: ['ASSET', 'LIABILITY', 'EQUITY'] }
            },
            include: {
                journalLines: {
                    where: {
                        journalEntry: {
                            entryDate: { lte: asOfDate },
                            status: 'POSTED' // Only Posted
                        }
                    }
                }
            }
        });

        const assets = accounts.filter(a => a.type === 'ASSET').map(a => ({
            ...a,
            amount: a.journalLines.reduce((sum, l) => sum + (Number(l.debit) - Number(l.credit)), 0)
        }));

        const liabilities = accounts.filter(a => a.type === 'LIABILITY').map(a => ({
            ...a,
            amount: a.journalLines.reduce((sum, l) => sum + (Number(l.credit) - Number(l.debit)), 0)
        }));

        const equity = accounts.filter(a => a.type === 'EQUITY').map(a => ({
            ...a,
            amount: a.journalLines.reduce((sum, l) => sum + (Number(l.credit) - Number(l.debit)), 0)
        }));

        const totalAsset = assets.reduce((sum, a) => sum + a.amount, 0);
        const totalLiability = liabilities.reduce((sum, a) => sum + a.amount, 0);
        const totalEquity = equity.reduce((sum, a) => sum + a.amount, 0);

        const retainedEarnings = totalAsset - (totalLiability + totalEquity);

        return {
            assets,
            liabilities,
            equity,
            totalAsset,
            totalLiability,
            totalEquity,
            retainedEarnings
        };
    }

    static async getAccountBalance(accountId: string, startDate?: Date, endDate?: Date) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const where: any = {
            accountId,
            journalEntry: { status: 'POSTED' }
        };

        if (startDate || endDate) {
            where.journalEntry.entryDate = {};
            if (startDate) where.journalEntry.entryDate.gte = startDate;
            if (endDate) where.journalEntry.entryDate.lte = endDate;
        }

        const lines = await prisma.journalLine.findMany({
            where,
            include: { journalEntry: true }
        });

        const account = await prisma.account.findUnique({ where: { id: accountId } });
        if (!account) throw new Error("Account not found");

        const isDebitNormal = ['ASSET', 'EXPENSE'].includes(account.type);

        const balance = lines.reduce((sum, line) => {
            const val = Number(line.debit) - Number(line.credit);
            return sum + (isDebitNormal ? val : -val);
        }, 0);

        return balance;
    }

    /**
     * Fiscal Periods Logic
     */

    static async getFiscalPeriods() {
        return await prisma.fiscalPeriod.findMany({
            orderBy: [{ year: 'desc' }, { month: 'desc' }]
        });
    }

    static async createFiscalPeriod(year: number, month: number) {
        const name = new Date(year, month - 1).toLocaleString('default', { month: 'long', year: 'numeric' });
        const startDate = new Date(year, month - 1, 1);
        const endDate = new Date(year, month, 0, 23, 59, 59);

        return await prisma.fiscalPeriod.create({
            data: {
                name,
                year,
                month,
                startDate,
                endDate,
                status: 'OPEN'
            }
        });
    }

    static async closeFiscalPeriod(id: string, userId: string) {
        return await prisma.fiscalPeriod.update({
            where: { id },
            data: {
                status: 'CLOSED',
                closedById: userId,
                closedAt: new Date()
            }
        });
    }

    /**
     * Check if a specific date is within an OPEN fiscal period
     */
    static async isPeriodOpen(date: Date): Promise<boolean> {
        const d = new Date(date);
        const year = d.getFullYear();
        const month = d.getMonth() + 1;

        const period = await prisma.fiscalPeriod.findUnique({
            where: { year_month: { year, month } }
        });

        // If no period defined, assume OPEN (or strictly enforce? Let's assume open for grace period)
        if (!period) return true;

        return period.status === 'OPEN';
    }
}
