
import { AccountingService } from '../accounting-service';
import { prisma } from '@/lib/prisma';
import { ReferenceType, JournalStatus } from '@prisma/client';

export class AutoJournalService {

    /**
     * Handle Sales Invoice Creation (AR -> Revenue + Tax)
     */
    static async handleSalesInvoiceCreated(invoiceId: string) {
        const invoice = await prisma.invoice.findUnique({
            where: { id: invoiceId },
            include: { salesOrder: true }
        });

        if (!invoice) throw new Error(`Invoice ${invoiceId} not found`);

        const AR_ACCOUNT = '11210';
        const REVENUE_ACCOUNT = '41100';
        const VAT_OUT_ACCOUNT = '21310';

        const arAccount = await this.getAccountByCode(AR_ACCOUNT);
        const revenueAccount = await this.getAccountByCode(REVENUE_ACCOUNT);
        const vatAccount = await this.getAccountByCode(VAT_OUT_ACCOUNT);

        const totalAmount = Number(invoice.totalAmount);
        const soTotal = Number(invoice.salesOrder.totalAmount || 0);
        const soTax = Number(invoice.salesOrder.taxAmount || 0);

        let taxAmount = 0;
        if (soTotal > 0 && soTax > 0) {
            const taxRate = soTax / (soTotal - soTax);
            const netAmount = totalAmount / (1 + taxRate);
            taxAmount = totalAmount - netAmount;
        }

        const subtotal = totalAmount - taxAmount;
        const journalStatus = invoice.status === 'DRAFT' ? JournalStatus.DRAFT : JournalStatus.POSTED;

        await AccountingService.createJournalEntry({
            entryDate: invoice.invoiceDate,
            description: `Sales Invoice #${invoice.invoiceNumber}`,
            reference: invoice.invoiceNumber,
            referenceType: ReferenceType.SALES_INVOICE,
            referenceId: invoice.id,
            isAutoGenerated: true,
            status: journalStatus,
            lines: [
                { accountId: arAccount.id, debit: totalAmount, credit: 0, description: `AR for ${invoice.invoiceNumber}` },
                { accountId: revenueAccount.id, debit: 0, credit: subtotal, description: `Revenue for ${invoice.invoiceNumber}` },
                { accountId: vatAccount.id, debit: 0, credit: taxAmount, description: `VAT Output for ${invoice.invoiceNumber}` }
            ]
        });
    }

    /**
     * Handle Purchase Invoice Created
     */
    static async handlePurchaseInvoiceCreated(invoiceId: string) {
        const invoice = await prisma.purchaseInvoice.findUnique({
            where: { id: invoiceId },
            include: { purchaseOrder: true }
        });

        if (!invoice) throw new Error(`Purchase Invoice ${invoiceId} not found`);

        const UNBILLED_ACCOUNT = '21120';
        const VAT_IN_ACCOUNT = '21320';
        const AP_ACCOUNT = '21110';

        const unbilledAcc = await this.getAccountByCode(UNBILLED_ACCOUNT);
        const vatInAcc = await this.getAccountByCode(VAT_IN_ACCOUNT);
        const apAcc = await this.getAccountByCode(AP_ACCOUNT);

        const totalAmount = Number(invoice.totalAmount);
        const taxAmount = 0; // Assumption for now
        const subtotal = totalAmount - taxAmount;
        const journalStatus = invoice.status === 'DRAFT' ? JournalStatus.DRAFT : JournalStatus.POSTED;

        await AccountingService.createJournalEntry({
            entryDate: invoice.invoiceDate,
            description: `Purchase Inv #${invoice.invoiceNumber} - ${invoice.purchaseOrder.orderNumber}`,
            reference: invoice.invoiceNumber,
            referenceType: ReferenceType.PURCHASE_INVOICE,
            referenceId: invoice.id,
            isAutoGenerated: true,
            status: journalStatus,
            lines: [
                { accountId: unbilledAcc.id, debit: subtotal, credit: 0, description: 'Clear Unbilled Accrual' },
                { accountId: vatInAcc.id, debit: taxAmount, credit: 0, description: 'VAT Input' },
                { accountId: apAcc.id, debit: 0, credit: totalAmount, description: 'Accounts Payable' }
            ]
        });
    }

    /**
     * Handle Sales Payment Received
     */
    static async handleSalesPayment(invoiceId: string, amount: number, method: string = 'Bank Transfer') {
        const invoice = await prisma.invoice.findUnique({ where: { id: invoiceId } });
        if (!invoice) return;

        // Map method to specific account
        const accountCode = this.getAccountCodeByMethod(method);
        const paymentAcc = await this.getAccountByCode(accountCode);
        const arAcc = await this.getAccountByCode('11210');

        await AccountingService.createJournalEntry({
            entryDate: new Date(),
            description: `Payment Receipt (${method}) for ${invoice.invoiceNumber}`,
            reference: `PAY-${invoice.invoiceNumber}`,
            referenceType: ReferenceType.SALES_PAYMENT,
            referenceId: invoice.id,
            isAutoGenerated: true,
            status: JournalStatus.POSTED,
            lines: [
                { accountId: paymentAcc.id, debit: amount, credit: 0, description: 'Payment In' },
                { accountId: arAcc.id, debit: 0, credit: amount, description: 'AR Payment' }
            ]
        });
    }

    /**
     * Handle Purchase Payment Sent
     */
    static async handlePurchasePayment(invoiceId: string, amount: number, method: string = 'Bank Transfer') {
        const invoice = await prisma.purchaseInvoice.findUnique({ where: { id: invoiceId } });
        if (!invoice) return;

        // Map method to specific account
        const accountCode = this.getAccountCodeByMethod(method);
        const paymentAcc = await this.getAccountByCode(accountCode);
        const apAcc = await this.getAccountByCode('21110'); // Accounts Payable

        await AccountingService.createJournalEntry({
            entryDate: new Date(),
            description: `Payment (${method}) for Purchase Invoice ${invoice.invoiceNumber}`,
            reference: `PAY-${invoice.invoiceNumber}`,
            referenceType: ReferenceType.PURCHASE_PAYMENT,
            referenceId: invoice.id,
            isAutoGenerated: true,
            status: JournalStatus.POSTED,
            lines: [
                { accountId: apAcc.id, debit: amount, credit: 0, description: 'AP Payment' },
                { accountId: paymentAcc.id, debit: 0, credit: amount, description: 'Payment Out' }
            ]
        });
    }

    /**
     * Helper to map human-readable method to account code
     */
    private static getAccountCodeByMethod(method: string): string {
        switch (method.toLowerCase()) {
            case 'cash':
                return '11110'; // Petty Cash/Kas
            case 'check':
            case 'bank transfer':
            case 'credit card':
            default:
                return '11120'; // Bank BCA (Default)
        }
    }



    /**
     * Handle Material Issue to Production (WIP -> Raw Materials)
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static async handleMaterialIssue(issueId: string) {
        // Deprecated: Now handled by AccountingService.recordInventoryMovement via ProductionMaterialService
        return;
    }

    /**
     * Handle Production Completion (Inventory FG -> WIP)
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static async handleProductionOutput(executionId: string) {
        // Deprecated: Now handled by AccountingService.recordInventoryMovement via ProductionExecutionService
        return;
    }

    /**
     * Handle Scrap Recording
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static async handleScrapOutput(scrapId: string) {
        // Deprecated: Now handled by AccountingService.recordInventoryMovement via ProductionMaterialService
        return;
    }

    /**
     * Handle Generic Stock Adjustment
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static async handleStockMovement(movementId: string) {
        // Deprecated: Now handled by AccountingService.recordInventoryMovement directly in services
        return;
    }

    private static async getAccountByCode(code: string) {
        const account = await prisma.account.findUnique({ where: { code } });
        if (!account) throw new Error(`Account code ${code} not found.`);
        return account;
    }
}
