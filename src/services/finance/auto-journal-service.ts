
import { AccountingService } from '@/services/accounting-service';
import { prisma } from '@/lib/prisma';
import { ReferenceType } from '@prisma/client';

export class AutoJournalService {

    /**
     * Handle Sales Invoice Creation (AR -> Revenue + Tax)
     */
    static async handleSalesInvoiceCreated(invoiceId: string) {
        const invoice = await prisma.invoice.findUnique({
            where: { id: invoiceId },
            include: { salesOrder: true }
        });

        if (!invoice) throw new Error(`Invoice ${invoiceId} not found`);

        const AR_ACCOUNT = '11210';
        const REVENUE_ACCOUNT = '41100';
        const VAT_OUT_ACCOUNT = '21310';

        const arAccount = await this.getAccountByCode(AR_ACCOUNT);
        const revenueAccount = await this.getAccountByCode(REVENUE_ACCOUNT);
        const vatAccount = await this.getAccountByCode(VAT_OUT_ACCOUNT);

        const totalAmount = Number(invoice.totalAmount);
        const soTotal = Number(invoice.salesOrder.totalAmount || 0);
        const soTax = Number(invoice.salesOrder.taxAmount || 0);

        let taxAmount = 0;
        if (soTotal > 0 && soTax > 0) {
            const taxRate = soTax / (soTotal - soTax);
            const netAmount = totalAmount / (1 + taxRate);
            taxAmount = totalAmount - netAmount;
        }

        const subtotal = totalAmount - taxAmount;

        await AccountingService.createJournalEntry({
            entryDate: invoice.invoiceDate,
            description: `Sales Invoice #${invoice.invoiceNumber}`,
            reference: invoice.invoiceNumber,
            referenceType: ReferenceType.SALES_INVOICE,
            referenceId: invoice.id,
            isAutoGenerated: true,
            lines: [
                { accountId: arAccount.id, debit: totalAmount, credit: 0, description: `AR for ${invoice.invoiceNumber}` },
                { accountId: revenueAccount.id, debit: 0, credit: subtotal, description: `Revenue for ${invoice.invoiceNumber}` },
                { accountId: vatAccount.id, debit: 0, credit: taxAmount, description: `VAT Output for ${invoice.invoiceNumber}` }
            ]
        });
    }

    /**
     * Handle Purchase Invoice Created
     */
    static async handlePurchaseInvoiceCreated(invoiceId: string) {
        const invoice = await prisma.purchaseInvoice.findUnique({
            where: { id: invoiceId },
            include: { purchaseOrder: true }
        });

        if (!invoice) throw new Error(`Purchase Invoice ${invoiceId} not found`);

        const INVENTORY_ACCOUNT = '11310';
        const VAT_IN_ACCOUNT = '21320';
        const AP_ACCOUNT = '21110';

        const inventoryAcc = await this.getAccountByCode(INVENTORY_ACCOUNT);
        const vatInAcc = await this.getAccountByCode(VAT_IN_ACCOUNT);
        const apAcc = await this.getAccountByCode(AP_ACCOUNT);

        const totalAmount = Number(invoice.totalAmount);
        const taxAmount = 0; // Assumption for now
        const subtotal = totalAmount - taxAmount;

        await AccountingService.createJournalEntry({
            entryDate: invoice.invoiceDate,
            description: `Purchase Inv #${invoice.invoiceNumber} - ${invoice.purchaseOrder.orderNumber}`,
            reference: invoice.invoiceNumber,
            referenceType: ReferenceType.PURCHASE_INVOICE,
            referenceId: invoice.id,
            isAutoGenerated: true,
            lines: [
                { accountId: inventoryAcc.id, debit: subtotal, credit: 0, description: 'Inventory/Expense' },
                { accountId: vatInAcc.id, debit: taxAmount, credit: 0, description: 'VAT Input' },
                { accountId: apAcc.id, debit: 0, credit: totalAmount, description: 'Accounts Payable' }
            ]
        });
    }

    /**
     * Handle Sales Payment Received
     */
    static async handleSalesPayment(invoiceId: string, amount: number) {
        const invoice = await prisma.invoice.findUnique({ where: { id: invoiceId } });
        if (!invoice) return;

        const bankAcc = await this.getAccountByCode('11120');
        const arAcc = await this.getAccountByCode('11210');

        await AccountingService.createJournalEntry({
            entryDate: new Date(),
            description: `Payment Receipt for ${invoice.invoiceNumber}`,
            reference: `PAY-${invoice.invoiceNumber}`,
            referenceType: ReferenceType.SALES_PAYMENT,
            referenceId: invoice.id,
            isAutoGenerated: true,
            lines: [
                { accountId: bankAcc.id, debit: amount, credit: 0, description: 'Cash In' },
                { accountId: arAcc.id, debit: 0, credit: amount, description: 'AR Payment' }
            ]
        });
    }

    /**
     * Handle Purchase Payment Sent
     */
    static async handlePurchasePayment(invoiceId: string, amount: number) {
        const invoice = await prisma.purchaseInvoice.findUnique({ where: { id: invoiceId } });
        if (!invoice) return;

        const bankAcc = await this.getAccountByCode('11120');
        const apAcc = await this.getAccountByCode('21110');

        await AccountingService.createJournalEntry({
            entryDate: new Date(),
            description: `Payment Sent for ${invoice.invoiceNumber}`,
            reference: `PAY-OUT-${invoice.invoiceNumber}`,
            referenceType: ReferenceType.PURCHASE_PAYMENT,
            referenceId: invoice.id,
            isAutoGenerated: true,
            lines: [
                { accountId: apAcc.id, debit: amount, credit: 0, description: 'AP Payment' },
                { accountId: bankAcc.id, debit: 0, credit: amount, description: 'Cash Out' }
            ]
        });
    }

    /**
     * Handle Material Issue to Production (WIP -> Raw Materials)
     */
    static async handleMaterialIssue(issueId: string) {
        const issue = await prisma.materialIssue.findUnique({
            where: { id: issueId },
            include: {
                productVariant: { include: { product: true } },
                productionOrder: { include: { bom: { include: { productVariant: { include: { product: true } } } } } }
            }
        });

        if (!issue) return;

        const rawMat = issue.productVariant;
        const targetFG = issue.productionOrder.bom.productVariant;

        const WIP_ACCOUNT = targetFG.product.wipAccountId || '11330';
        const RAW_INV_ACCOUNT = rawMat.product.inventoryAccountId || '11310';

        const wipAcc = await this.getAccountByCode(WIP_ACCOUNT);
        const invAcc = await this.getAccountByCode(RAW_INV_ACCOUNT);

        const totalValue = Number(issue.quantity) * Number(rawMat.standardCost || rawMat.buyPrice || 0);

        if (totalValue <= 0) return;

        await AccountingService.createJournalEntry({
            entryDate: issue.issuedAt,
            description: `Material Issue: ${rawMat.skuCode} for ${issue.productionOrder.orderNumber}`,
            reference: issue.productionOrder.orderNumber,
            referenceType: ReferenceType.MATERIAL_ISSUE,
            referenceId: issue.id,
            isAutoGenerated: true,
            lines: [
                { accountId: wipAcc.id, debit: totalValue, credit: 0, description: 'WIP Increase' },
                { accountId: invAcc.id, debit: 0, credit: totalValue, description: 'Inventory Out' }
            ]
        });
    }

    /**
     * Handle Production Completion (Inventory FG -> WIP)
     */
    static async handleProductionOutput(executionId: string) {
        const execution = await prisma.productionExecution.findUnique({
            where: { id: executionId },
            include: {
                productionOrder: {
                    include: {
                        bom: { include: { productVariant: { include: { product: true } } } }
                    }
                }
            }
        });

        if (!execution || !execution.endTime) return;

        const fg = execution.productionOrder.bom.productVariant;
        const FG_INV_ACCOUNT = fg.product.inventoryAccountId || '11320';
        const WIP_ACCOUNT = fg.product.wipAccountId || '11330';

        const fgAcc = await this.getAccountByCode(FG_INV_ACCOUNT);
        const wipAcc = await this.getAccountByCode(WIP_ACCOUNT);

        const totalValue = Number(execution.quantityProduced) * Number(fg.standardCost || 0);

        if (totalValue <= 0) return;

        await AccountingService.createJournalEntry({
            entryDate: execution.endTime,
            description: `Finish Good Output: ${fg.skuCode} - ${execution.productionOrder.orderNumber}`,
            reference: execution.productionOrder.orderNumber,
            referenceType: ReferenceType.PRODUCTION_OUTPUT,
            referenceId: execution.id,
            isAutoGenerated: true,
            lines: [
                { accountId: fgAcc.id, debit: totalValue, credit: 0, description: 'FG Increase' },
                { accountId: wipAcc.id, debit: 0, credit: totalValue, description: 'WIP Clearance' }
            ]
        });
    }

    /**
     * Handle Scrap Recording
     */
    static async handleScrapOutput(scrapId: string) {
        const scrap = await prisma.scrapRecord.findUnique({
            where: { id: scrapId },
            include: {
                productVariant: { include: { product: true } },
                productionOrder: true
            }
        });

        if (!scrap) return;

        const scrapVar = scrap.productVariant;
        const SCRAP_INV_ACCOUNT = scrapVar.product.inventoryAccountId || '11390';
        const RECOVERY_ACCOUNT = '54000';

        const scrapAcc = await this.getAccountByCode(SCRAP_INV_ACCOUNT);
        const recoveryAcc = await this.getAccountByCode(RECOVERY_ACCOUNT);

        const totalValue = Number(scrap.quantity) * Number(scrapVar.standardCost || 0);

        if (totalValue <= 0) return;

        await AccountingService.createJournalEntry({
            entryDate: scrap.recordedAt,
            description: `Scrap Recovery: ${scrapVar.skuCode} from ${scrap.productionOrder.orderNumber}`,
            reference: scrap.productionOrder.orderNumber,
            referenceType: ReferenceType.STOCK_ADJUSTMENT,
            referenceId: scrap.id,
            isAutoGenerated: true,
            lines: [
                { accountId: scrapAcc.id, debit: totalValue, credit: 0, description: 'Scrap/Regrind Inv' },
                { accountId: recoveryAcc.id, debit: 0, credit: totalValue, description: 'Cost Recovery' }
            ]
        });
    }

    /**
     * Handle Generic Stock Adjustment
     */
    static async handleStockMovement(movementId: string) {
        const movement = await prisma.stockMovement.findUnique({
            where: { id: movementId },
            include: { productVariant: { include: { product: true } } }
        });

        if (!movement || movement.type !== 'ADJUSTMENT') return;

        const targetAccount = movement.productVariant.product.inventoryAccountId || '11310';
        const expenseAccount = '53300';

        const invAcc = await this.getAccountByCode(targetAccount);
        const expenseAcc = await this.getAccountByCode(expenseAccount);

        const quantity = Number(movement.quantity);
        const unitCost = Number(movement.cost || movement.productVariant.standardCost || movement.productVariant.buyPrice || 0);
        const totalValue = Math.abs(quantity * unitCost);

        if (totalValue === 0) return;

        const isGain = quantity > 0;

        await AccountingService.createJournalEntry({
            entryDate: movement.createdAt,
            description: `Stock Adj: ${movement.reference || 'Manual'} - ${movement.productVariant.skuCode}`,
            reference: movement.reference || 'ADJUSTMENT',
            referenceType: ReferenceType.STOCK_ADJUSTMENT,
            referenceId: movement.id,
            isAutoGenerated: true,
            lines: isGain ? [
                { accountId: invAcc.id, debit: totalValue, credit: 0, description: 'Stock Found' },
                { accountId: expenseAcc.id, debit: 0, credit: totalValue, description: 'Adjustment Gain' }
            ] : [
                { accountId: expenseAcc.id, debit: totalValue, credit: 0, description: 'Adjustment Loss' },
                { accountId: invAcc.id, debit: 0, credit: totalValue, description: 'Stock Loss' }
            ]
        });
    }

    private static async getAccountByCode(code: string) {
        const account = await prisma.account.findUnique({ where: { code } });
        if (!account) throw new Error(`Account code ${code} not found.`);
        return account;
    }
}
