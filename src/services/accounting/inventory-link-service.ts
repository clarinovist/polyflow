import { prisma } from '@/lib/prisma';
import { Prisma, StockMovement, JournalStatus } from '@prisma/client';
import { createJournalEntry } from './journals-service';

type StockMovementWithProduct = Prisma.StockMovementGetPayload<{
    include: { productVariant: { include: { product: true } } }
}>;

export async function recordInventoryMovement(
    movement: StockMovement & { productVariant?: StockMovementWithProduct['productVariant'] },
    tx?: Prisma.TransactionClient
) {
    const db = tx || prisma;

    const productVariant = movement.productVariant ?? await db.productVariant.findUnique({
        where: { id: movement.productVariantId },
        include: { product: true }
    });

    if (!productVariant) return;

    const date = movement.createdAt || new Date();
    const cost = Number(productVariant.standardCost || productVariant.price || 0);
    const totalAmount = Number(movement.quantity) * cost;

    if (totalAmount === 0) return;

    const productType = productVariant.product.productType;

    const getInventoryAccount = (pType: string) => {
        switch (pType) {
            case 'RAW_MATERIAL': return '11310';
            case 'FINISHED_GOOD': return '11330';
            case 'WIP': return '11320';
            case 'SCRAP': return '11390';
            case 'INTERMEDIATE': return '11320';
            case 'PACKAGING': return '11310';
            default: return '11310';
        }
    };

    const lines = [];

    if (movement.type === 'PURCHASE' || movement.goodsReceiptId) {
        const invAccount = getInventoryAccount(productType);
        lines.push(
            { accountId: (await getAccountId(invAccount)), debit: totalAmount, credit: 0, description: `GR: ${productVariant.name}` },
            { accountId: (await getAccountId('21110')), debit: 0, credit: totalAmount, description: `AP Accrual: ${productVariant.name}` }
        );
    }

    else if (movement.type === 'OUT' && movement.salesOrderId) {
        const invAccount = getInventoryAccount(productType);
        lines.push(
            { accountId: (await getAccountId('50000')), debit: totalAmount, credit: 0, description: `COGS: ${productVariant.name}` },
            { accountId: (await getAccountId(invAccount)), debit: 0, credit: totalAmount, description: `Shipment: ${productVariant.name}` }
        );
    }

    else if (movement.type === 'OUT' && !movement.salesOrderId) {
        const creditAccount = getInventoryAccount(productType);
        lines.push(
            { accountId: (await getAccountId('11320')), debit: totalAmount, credit: 0, description: `Production Issue: ${productVariant.name}` },
            { accountId: (await getAccountId(creditAccount)), debit: 0, credit: totalAmount, description: `Material Consumed` }
        );
    }

    else if (movement.type === 'IN' && !movement.goodsReceiptId) {
        const debitAccount = getInventoryAccount(productType);
        lines.push(
            { accountId: (await getAccountId(debitAccount)), debit: totalAmount, credit: 0, description: `Production Output: ${productVariant.name}` },
            { accountId: (await getAccountId('11320')), debit: 0, credit: totalAmount, description: `WIP Relief` }
        );
    }

    else if (movement.type === 'ADJUSTMENT') {
        const invAccount = getInventoryAccount(productType);
        const absAmt = Math.abs(totalAmount);

        if (Number(movement.quantity) > 0) {
            lines.push(
                { accountId: (await getAccountId(invAccount)), debit: absAmt, credit: 0, description: `Stock Adj (In)` },
                { accountId: (await getAccountId('53300')), debit: 0, credit: absAmt, description: `Adj Gain` }
            );
        } else {
            lines.push(
                { accountId: (await getAccountId('53300')), debit: absAmt, credit: 0, description: `Adj Loss` },
                { accountId: (await getAccountId(invAccount)), debit: 0, credit: absAmt, description: `Stock Adj (Out)` }
            );
        }
    }

    if (lines.length > 0) {
        await createJournalEntry({
            entryDate: date,
            description: `Auto: ${movement.type} - ${productVariant.name}`,
            reference: movement.reference || movement.id,
            referenceType: movement.type === 'PURCHASE' ? 'GOODS_RECEIPT' : (movement.type === 'ADJUSTMENT' ? 'STOCK_ADJUSTMENT' : 'MANUAL_ENTRY'),
            referenceId: movement.id,
            isAutoGenerated: true,
            status: JournalStatus.POSTED,
            lines,
            createdById: movement.createdById ?? undefined
        }, tx);
    }
}

async function getAccountId(code: string): Promise<string> {
    const acc = await prisma.account.findUnique({ where: { code } });
    if (!acc) throw new Error(`GL Account code ${code} not found during auto-journal.`);
    return acc.id;
}
