import { prisma } from '@/lib/prisma';
import { JournalStatus, Prisma, ReferenceType } from '@prisma/client';
import type { CreateJournalEntryInput } from './types';
import { isPeriodOpen } from '@/services/accounting/periods-service';

export async function createJournalEntry(input: CreateJournalEntryInput, tx?: Prisma.TransactionClient) {
    const { lines } = input;

    const totalDebit = lines.reduce((sum, line) => sum + Number(line.debit), 0);
    const totalCredit = lines.reduce((sum, line) => sum + Number(line.credit), 0);

    if (Math.abs(totalDebit - totalCredit) > 0.01) {
        throw new Error(`Journal Entry is not balanced. Debit: ${totalDebit}, Credit: ${totalCredit}`);
    }

    const isOpen = await isPeriodOpen(input.entryDate);
    if (!isOpen) {
        throw new Error("Cannot create journal entry in a closed fiscal period.");
    }

    const maxRetries = 3;
    let lastError: unknown;

    for (let i = 0; i < maxRetries; i++) {
        try {
            // We use a transaction to ensure entryNumber generation and entry creation are atomic
            // If tx is provided from outside, we use it directly (no retry inside if outer tx aborts)
            // If no tx provided, we start one and retry on conflict
            const executeInTx = async (db: Prisma.TransactionClient) => {
                const entryNumber = await generateEntryNumber(input.entryDate, db);

                return await db.journalEntry.create({
                    data: {
                        entryNumber,
                        entryDate: input.entryDate,
                        description: input.description,
                        reference: input.reference,
                        referenceType: input.referenceType,
                        referenceId: input.referenceId,
                        status: input.status || JournalStatus.DRAFT,
                        isAutoGenerated: input.isAutoGenerated || false,
                        createdById: input.createdById,
                        lines: {
                            create: lines.map(line => ({
                                accountId: line.accountId,
                                debit: line.debit,
                                credit: line.credit,
                                description: line.description
                            }))
                        }
                    },
                    include: {
                        lines: {
                            include: { account: true }
                        }
                    }
                });
            };

            if (tx) {
                return await executeInTx(tx);
            } else {
                return await prisma.$transaction(async (innerTx) => {
                    return await executeInTx(innerTx);
                }, {
                    isolationLevel: Prisma.TransactionIsolationLevel.Serializable // High isolation for numbering
                });
            }
        } catch (error) {
            lastError = error;
            // Check for Unique Constraint Violation (P2002) on entryNumber
            if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
                const target = (error.meta?.target as string[]) || [];
                if (target.includes('entryNumber') && !tx) {
                    console.warn(`[JournalService] entryNumber collision detected, retrying... (${i + 1}/${maxRetries})`);
                    // Small delay before retry
                    await new Promise(resolve => setTimeout(resolve, 50 * (i + 1)));
                    continue;
                }
            }
            throw error;
        }
    }

    throw lastError;
}

export async function postJournal(id: string, userId?: string, tx?: Prisma.TransactionClient) {
    const db = tx || prisma;
    const journal = await db.journalEntry.findUnique({
        where: { id },
        include: { lines: true }
    });

    if (!journal) throw new Error("Journal not found");
    // if (journal.status !== 'DRAFT') throw new Error("Only DRAFT journals can be posted");

    const isOpen = await isPeriodOpen(journal.entryDate, tx);
    if (!isOpen) {
        throw new Error("Cannot post journal entry to a closed fiscal period.");
    }

    return await db.journalEntry.update({
        where: { id },
        data: {
            status: 'POSTED',
            approvedById: userId,
            approvedAt: new Date()
        }
    });
}

export async function postBulkJournals(ids: string[], userId?: string) {
    return await prisma.journalEntry.updateMany({
        where: {
            id: { in: ids },
            status: 'DRAFT'
        },
        data: {
            status: 'POSTED',
            approvedById: userId,
            approvedAt: new Date()
        }
    });
}

export async function voidJournal(id: string, _userId?: string) {
    const journal = await prisma.journalEntry.findUnique({
        where: { id }
    });

    if (!journal) throw new Error("Journal not found");
    if (journal.status !== 'POSTED') throw new Error("Only POSTED journals can be voided");

    return await prisma.journalEntry.update({
        where: { id },
        data: {
            status: 'VOIDED'
        }
    });
}

export async function reverseJournal(id: string, userId?: string) {
    const original = await prisma.journalEntry.findUnique({
        where: { id },
        include: { lines: true }
    });

    if (!original) throw new Error("Journal not found");
    if (original.status !== 'POSTED') throw new Error("Only POSTED journals can be reversed");

    const reversalLines = original.lines.map(l => ({
        accountId: l.accountId,
        debit: Number(l.credit),
        credit: Number(l.debit),
        description: `Reversal of ${original.entryNumber}: ${l.description || ''} `
    }));

    return await createJournalEntry({
        entryDate: new Date(),
        description: `Reversal of ${original.description} `,
        reference: original.entryNumber,
        referenceType: 'MANUAL_ENTRY',
        createdById: userId,
        lines: reversalLines
    });
}

export async function createBulkJournalEntries(data: CreateJournalEntryInput[]) {
    const maxRetries = 3;
    let lastError: unknown;

    for (let i = 0; i < maxRetries; i++) {
        try {
            return await prisma.$transaction(async (tx) => {
                const results = [];
                for (const entry of data) {
                    const totalDebit = entry.lines.reduce((sum, l) => sum + (Number(l.debit) || 0), 0);
                    const totalCredit = entry.lines.reduce((sum, l) => sum + (Number(l.credit) || 0), 0);
                    if (Math.abs(totalDebit - totalCredit) > 0.01) {
                        throw new Error(`Unbalanced journal for reference ${entry.reference}`);
                    }

                    const entryNumber = await generateEntryNumber(entry.entryDate, tx);

                    const je = await tx.journalEntry.create({
                        data: {
                            entryNumber,
                            entryDate: entry.entryDate,
                            description: entry.description,
                            reference: entry.reference,
                            referenceType: entry.referenceType as ReferenceType,
                            createdById: entry.createdById,
                            isAutoGenerated: entry.isAutoGenerated,
                            status: entry.status || JournalStatus.DRAFT,
                            lines: {
                                create: entry.lines.map(l => ({
                                    accountId: l.accountId,
                                    debit: l.debit,
                                    credit: l.credit,
                                    description: l.description,
                                    currency: 'IDR',
                                    exchangeRate: 1
                                }))
                            }
                        }
                    });
                    results.push(je);
                }
                return results;
            }, {
                isolationLevel: Prisma.TransactionIsolationLevel.Serializable
            });
        } catch (error) {
            lastError = error;
            if (error instanceof Prisma.PrismaClientKnownRequestError &&
                (error.code === 'P2002' || error.code === 'P2034' || error.message.includes('serialization failure'))) {
                console.warn(`[JournalService] Bulk collision or serialization error, retrying... (${i + 1}/${maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, 100 * (i + 1)));
                continue;
            }
            throw error;
        }
    }
    throw lastError;
}

export async function getJournals(params?: { startDate?: Date, endDate?: Date, status?: JournalStatus, reference?: string }) {
    const where: Prisma.JournalEntryWhereInput = {};

    if (params?.startDate && params?.endDate) {
        where.entryDate = { gte: params.startDate, lte: params.endDate };
    }
    if (params?.status) {
        where.status = params.status;
    }
    if (params?.reference) {
        where.reference = { contains: params.reference, mode: 'insensitive' };
    }

    return await prisma.journalEntry.findMany({
        where,
        include: {
            createdBy: { select: { name: true } },
            lines: true
        },
        orderBy: { entryDate: 'desc' }
    });
}

export async function getJournalById(id: string) {
    return await prisma.journalEntry.findUnique({
        where: { id },
        include: {
            lines: {
                include: { account: true }
            },
            createdBy: { select: { name: true } },
            approvedBy: { select: { name: true } }
        }
    });
}

async function generateEntryNumber(date: Date, tx?: Prisma.TransactionClient): Promise<string> {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const db = (tx || prisma) as any;
    const year = date.getFullYear();
    const key = `JOURNAL_ENTRY_${year}`;

    try {
        // Try to increment existing sequence
        const sequence = await db.systemSequence.update({
            where: { key },
            data: { value: { increment: 1 } }
        });
        const currentVal = Number(sequence.value) - 1;
        return `JE - ${year} -${currentVal.toString().padStart(5, '0')}`;
    } catch (error) {
        // Record not found (P2025) means sequence hasn't been initialized for this year
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            const latestEntry = await (tx || prisma).journalEntry.findFirst({
                where: {
                    entryDate: {
                        gte: new Date(year, 0, 1),
                        lt: new Date(year + 1, 0, 1)
                    }
                },
                orderBy: { entryNumber: 'desc' }
            });

            let startValue = 1;
            if (latestEntry && latestEntry.entryNumber) {
                // JE - 2026 -00003
                const parts = latestEntry.entryNumber.split('-');
                const lastPart = parts[parts.length - 1].trim();
                const lastNum = parseInt(lastPart, 10);
                if (!isNaN(lastNum)) {
                    startValue = lastNum + 1;
                }
            }

            const sequence = await db.systemSequence.upsert({
                where: { key },
                update: { value: { increment: 1 } },
                create: { key, value: BigInt(startValue + 1) }
            });
            const currentVal = Number(sequence.value) - 1;
            return `JE - ${year} -${currentVal.toString().padStart(5, '0')}`;
        }
        throw error;
    }
}
