import { prisma } from '@/lib/prisma';
import { JournalStatus, Prisma } from '@prisma/client';
import type { CreateJournalEntryInput } from './types';
import { isPeriodOpen } from '@/services/accounting/periods-service';

export async function createJournalEntry(input: CreateJournalEntryInput, tx?: Prisma.TransactionClient) {
    const db = tx || prisma;
    const { lines } = input;

    const totalDebit = lines.reduce((sum, line) => sum + Number(line.debit), 0);
    const totalCredit = lines.reduce((sum, line) => sum + Number(line.credit), 0);

    if (Math.abs(totalDebit - totalCredit) > 0.01) {
        throw new Error(`Journal Entry is not balanced.Debit: ${totalDebit}, Credit: ${totalCredit} `);
    }

    const isOpen = await isPeriodOpen(input.entryDate);
    if (!isOpen) {
        throw new Error("Cannot create journal entry in a closed fiscal period.");
    }

    return await db.journalEntry.create({
        data: {
            entryNumber: await generateEntryNumber(input.entryDate),
            entryDate: input.entryDate,
            description: input.description,
            reference: input.reference,
            referenceType: input.referenceType,
            referenceId: input.referenceId,
            status: JournalStatus.DRAFT,
            isAutoGenerated: input.isAutoGenerated || false,
            createdById: input.createdById,
            lines: {
                create: lines.map(line => ({
                    accountId: line.accountId,
                    debit: line.debit,
                    credit: line.credit,
                    description: line.description
                }))
            }
        },
        include: {
            lines: {
                include: { account: true }
            }
        }
    });
}

export async function postJournal(id: string, userId?: string) {
    const journal = await prisma.journalEntry.findUnique({
        where: { id },
        include: { lines: true }
    });

    if (!journal) throw new Error("Journal not found");
    if (journal.status !== 'DRAFT') throw new Error("Only DRAFT journals can be posted");

    const isOpen = await isPeriodOpen(journal.entryDate);
    if (!isOpen) {
        throw new Error("Cannot post journal entry to a closed fiscal period.");
    }

    return await prisma.journalEntry.update({
        where: { id },
        data: {
            status: 'POSTED',
            approvedById: userId,
            approvedAt: new Date()
        }
    });
}

export async function voidJournal(id: string, _userId?: string) {
    const journal = await prisma.journalEntry.findUnique({
        where: { id }
    });

    if (!journal) throw new Error("Journal not found");
    if (journal.status !== 'POSTED') throw new Error("Only POSTED journals can be voided");

    return await prisma.journalEntry.update({
        where: { id },
        data: {
            status: 'VOIDED'
        }
    });
}

export async function reverseJournal(id: string, userId?: string) {
    const original = await prisma.journalEntry.findUnique({
        where: { id },
        include: { lines: true }
    });

    if (!original) throw new Error("Journal not found");
    if (original.status !== 'POSTED') throw new Error("Only POSTED journals can be reversed");

    const reversalLines = original.lines.map(l => ({
        accountId: l.accountId,
        debit: Number(l.credit),
        credit: Number(l.debit),
        description: `Reversal of ${original.entryNumber}: ${l.description || ''} `
    }));

    return await createJournalEntry({
        entryDate: new Date(),
        description: `Reversal of ${original.description} `,
        reference: original.entryNumber,
        referenceType: 'MANUAL_ENTRY',
        createdById: userId,
        lines: reversalLines
    });
}

export async function createBulkJournalEntries(data: CreateJournalEntryInput[]) {
    return await prisma.$transaction(async (tx) => {
        const results = [];
        for (const entry of data) {
            const totalDebit = entry.lines.reduce((sum, l) => sum + (Number(l.debit) || 0), 0);
            const totalCredit = entry.lines.reduce((sum, l) => sum + (Number(l.credit) || 0), 0);
            if (Math.abs(totalDebit - totalCredit) > 0.01) {
                throw new Error(`Unbalanced journal for reference ${entry.reference}`);
            }

            const entryYear = new Date(entry.entryDate).getFullYear();
            const count = await tx.journalEntry.count({
                where: { entryDate: { gte: new Date(entryYear, 0, 1), lt: new Date(entryYear + 1, 0, 1) } }
            });
            const entryNumber: string = `JE - ${entryYear} -${(count + 1 + results.length).toString().padStart(5, '0')} `;

            const je = await tx.journalEntry.create({
                data: {
                    entryNumber,
                    entryDate: entry.entryDate,
                    description: entry.description,
                    reference: entry.reference,
                    referenceType: entry.referenceType,
                    createdById: entry.createdById,
                    isAutoGenerated: entry.isAutoGenerated,
                    status: JournalStatus.DRAFT,
                    lines: {
                        create: entry.lines.map(l => ({
                            accountId: l.accountId,
                            debit: l.debit,
                            credit: l.credit,
                            description: l.description,
                            currency: 'IDR',
                            exchangeRate: 1
                        }))
                    }
                }
            });
            results.push(je);
        }
        return results;
    });
}

export async function getJournals(params?: { startDate?: Date, endDate?: Date, status?: JournalStatus, reference?: string }) {
    const where: Prisma.JournalEntryWhereInput = {};

    if (params?.startDate && params?.endDate) {
        where.entryDate = { gte: params.startDate, lte: params.endDate };
    }
    if (params?.status) {
        where.status = params.status;
    }
    if (params?.reference) {
        where.reference = { contains: params.reference, mode: 'insensitive' };
    }

    return await prisma.journalEntry.findMany({
        where,
        include: {
            createdBy: { select: { name: true } },
            lines: true
        },
        orderBy: { entryDate: 'desc' }
    });
}

export async function getJournalById(id: string) {
    return await prisma.journalEntry.findUnique({
        where: { id },
        include: {
            lines: {
                include: { account: true }
            },
            createdBy: { select: { name: true } },
            approvedBy: { select: { name: true } }
        }
    });
}

async function generateEntryNumber(date: Date): Promise<string> {
    const year = date.getFullYear();
    const startOfYear = new Date(year, 0, 1);
    const endOfYear = new Date(year, 11, 31, 23, 59, 59);

    const count = await prisma.journalEntry.count({
        where: {
            entryDate: {
                gte: startOfYear,
                lte: endOfYear
            }
        }
    });

    const sequence = (count + 1).toString().padStart(5, '0');
    return `JE - ${year} -${sequence} `;
}
