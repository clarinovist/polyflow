import { prisma } from '@/lib/prisma';
import { JournalStatus, Prisma, ReferenceType } from '@prisma/client';
import type { CreateJournalEntryInput } from './types';
import { isPeriodOpen } from '@/services/accounting/periods-service';
import { getClosingBalances } from './reports-service';

export async function createClosingJournalEntry(periodId: string, userId: string, tx?: Prisma.TransactionClient) {
    const db = tx || prisma;

    const period = await db.fiscalPeriod.findUnique({ where: { id: periodId } });
    if (!period) throw new Error("Period not found");

    const reference = `CLOSING-${period.name.replace(/\s+/g, '-')}`;

    // 1. Re-close capability: Delete existing closing entry if it exists
    const existing = await db.journalEntry.findFirst({
        where: { reference }
    });

    if (existing) {
        // We delete to keep it clean. 
        await db.journalLine.deleteMany({ where: { journalEntryId: existing.id } });
        await db.journalEntry.delete({ where: { id: existing.id } });
    }

    const balances = await getClosingBalances(period.startDate, period.endDate);
    if (balances.length === 0) return null;

    let totalNetIncome = 0;
    const lines = balances.map(b => {
        const isRevenue = b.type === 'REVENUE';
        const amount = Math.abs(b.netBalance);

        totalNetIncome += (isRevenue ? b.netBalance : -b.netBalance);

        return {
            accountId: b.id,
            debit: isRevenue ? amount : 0,
            credit: isRevenue ? 0 : amount,
            description: `Closing Entry for ${period.name}`
        };
    });

    const earningsAccount = await db.account.findUnique({ where: { code: '33000' } });
    if (!earningsAccount) throw new Error("Earnings account (33000) not found in COA");

    lines.push({
        accountId: earningsAccount.id,
        debit: totalNetIncome < 0 ? Math.abs(totalNetIncome) : 0,
        credit: totalNetIncome > 0 ? Math.abs(totalNetIncome) : 0,
        description: `Net Income Transfer for ${period.name}`
    });

    return await createJournalEntry({
        entryDate: period.endDate,
        description: `Closing Entries for ${period.name}`,
        reference,
        referenceType: 'MANUAL_ENTRY',
        status: 'POSTED',
        isAutoGenerated: true,
        createdById: userId,
        lines
    }, tx);
}

/**
 * Transfers Year-End accumulated balance from Current Year Earnings (33000)
 * to Retained Earnings (32000)
 */
export async function createYearEndClosingEntry(year: number, userId: string, tx?: Prisma.TransactionClient) {
    const db = tx || prisma;
    const reference = `YEAREND-${year}`;

    // 1. Re-close check
    const existing = await db.journalEntry.findFirst({ where: { reference } });
    if (existing) {
        await db.journalLine.deleteMany({ where: { journalEntryId: existing.id } });
        await db.journalEntry.delete({ where: { id: existing.id } });
    }

    // 2. Get Balance of Current Year Earnings (33000)
    const earningsAccount = await db.account.findUnique({ where: { code: '33000' } });
    if (!earningsAccount) throw new Error("Current Year Earnings account (33000) not found");

    const retainedEarningsAccount = await db.account.findUnique({ where: { code: '32000' } });
    if (!retainedEarningsAccount) throw new Error("Retained Earnings account (32000) not found");

    // Calculate sum of all journal lines for 33000 in this year
    const journalLines = await db.journalLine.findMany({
        where: {
            accountId: earningsAccount.id,
            journalEntry: {
                entryDate: {
                    gte: new Date(year, 0, 1),
                    lte: new Date(year, 11, 31, 23, 59, 59)
                },
                status: 'POSTED'
            }
        }
    });

    const totalDebit = journalLines.reduce((sum, l) => sum + Number(l.debit), 0);
    const totalCredit = journalLines.reduce((sum, l) => sum + Number(l.credit), 0);
    const balance = totalCredit - totalDebit; // Credit Normal

    if (Math.abs(balance) < 0.01) {
        throw new Error(`No balance in Current Year Earnings (33000) for year ${year} to transfer.`);
    }

    // 3. Create Transfer Entry
    const closingLines = [
        {
            accountId: earningsAccount.id,
            debit: balance > 0 ? balance : 0,
            credit: balance < 0 ? Math.abs(balance) : 0,
            description: `Year-End Transfer of Earnings to Retained Earnings - ${year}`
        },
        {
            accountId: retainedEarningsAccount.id,
            debit: balance < 0 ? Math.abs(balance) : 0,
            credit: balance > 0 ? balance : 0,
            description: `Transferred from Current Year Earnings - ${year}`
        }
    ];

    return await createJournalEntry({
        entryDate: new Date(year, 11, 31, 23, 59, 59),
        description: `Year-End Closing Entry ${year}`,
        reference,
        referenceType: 'MANUAL_ENTRY',
        status: 'POSTED',
        isAutoGenerated: true,
        createdById: userId,
        lines: closingLines
    }, tx);
}


export async function createJournalEntry(input: CreateJournalEntryInput, tx?: Prisma.TransactionClient) {
    const { lines } = input;

    const totalDebit = lines.reduce((sum, line) => sum + Number(line.debit), 0);
    const totalCredit = lines.reduce((sum, line) => sum + Number(line.credit), 0);

    if (Math.abs(totalDebit - totalCredit) > 0.01) {
        throw new Error(`Journal Entry is not balanced. Debit: ${totalDebit}, Credit: ${totalCredit}`);
    }

    // Validation: Prevent manual entries to Control Accounts (AR & Inventory)
    if (!input.isAutoGenerated && input.referenceType === 'MANUAL_ENTRY') {
        const db = tx || prisma;
        const accountIds = lines.map(l => l.accountId);
        const controlAccounts = await db.account.findMany({
            where: {
                id: { in: accountIds },
                OR: [
                    { code: { startsWith: '112' } }, // Accounts Receivable
                    { code: { startsWith: '113' } }  // Inventory
                ]
            }
        });

        if (controlAccounts.length > 0) {
            const codes = controlAccounts.map(a => a.code).join(', ');
            throw new Error(`Manual journal entry is forbidden for Control Accounts: ${codes}. Please use the Receive Payment, Bill Payment, or Inventory modules instead to ensure data consistency.`);
        }
    }

    const isOpen = await isPeriodOpen(input.entryDate);
    if (!isOpen) {
        throw new Error("Cannot create journal entry in a closed fiscal period.");
    }

    const maxRetries = 3;
    let lastError: unknown;

    for (let i = 0; i < maxRetries; i++) {
        try {
            // We use a transaction to ensure entryNumber generation and entry creation are atomic
            // If tx is provided from outside, we use it directly (no retry inside if outer tx aborts)
            // If no tx provided, we start one and retry on conflict
            const executeInTx = async (db: Prisma.TransactionClient) => {
                const entryNumber = await generateEntryNumber(input.entryDate, db);

                return await db.journalEntry.create({
                    data: {
                        entryNumber,
                        entryDate: input.entryDate,
                        description: input.description,
                        reference: input.reference,
                        referenceType: input.referenceType,
                        referenceId: input.referenceId,
                        status: input.status || JournalStatus.DRAFT,
                        isAutoGenerated: input.isAutoGenerated || false,
                        createdById: input.createdById,
                        lines: {
                            create: lines.map(line => ({
                                accountId: line.accountId,
                                debit: line.debit,
                                credit: line.credit,
                                description: line.description
                            }))
                        }
                    },
                    include: {
                        lines: {
                            include: { account: true }
                        }
                    }
                });
            };

            if (tx) {
                return await executeInTx(tx);
            } else {
                return await prisma.$transaction(async (innerTx) => {
                    return await executeInTx(innerTx);
                }, {
                    isolationLevel: Prisma.TransactionIsolationLevel.Serializable // High isolation for numbering
                });
            }
        } catch (error) {
            lastError = error;
            // Check for Unique Constraint Violation (P2002) on entryNumber
            if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
                const target = (error.meta?.target as string[]) || [];
                if (target.includes('entryNumber') && !tx) {
                    console.warn(`[JournalService] entryNumber collision detected, retrying... (${i + 1}/${maxRetries})`);
                    // Small delay before retry
                    await new Promise(resolve => setTimeout(resolve, 50 * (i + 1)));
                    continue;
                }
            }
            throw error;
        }
    }

    throw lastError;
}

export async function postJournal(id: string, userId?: string, tx?: Prisma.TransactionClient) {
    const db = tx || prisma;
    const journal = await db.journalEntry.findUnique({
        where: { id },
        include: { lines: true }
    });

    if (!journal) throw new Error("Journal not found");
    // if (journal.status !== 'DRAFT') throw new Error("Only DRAFT journals can be posted");

    const isOpen = await isPeriodOpen(journal.entryDate, tx);
    if (!isOpen) {
        throw new Error("Cannot post journal entry to a closed fiscal period.");
    }

    return await db.journalEntry.update({
        where: { id },
        data: {
            status: 'POSTED',
            approvedById: userId,
            approvedAt: new Date()
        }
    });
}

export async function postBulkJournals(ids: string[], userId?: string) {
    return await prisma.journalEntry.updateMany({
        where: {
            id: { in: ids },
            status: 'DRAFT'
        },
        data: {
            status: 'POSTED',
            approvedById: userId,
            approvedAt: new Date()
        }
    });
}

export async function voidJournal(id: string, _userId?: string) {
    const journal = await prisma.journalEntry.findUnique({
        where: { id }
    });

    if (!journal) throw new Error("Journal not found");
    if (journal.status !== 'POSTED') throw new Error("Only POSTED journals can be voided");

    return await prisma.journalEntry.update({
        where: { id },
        data: {
            status: 'VOIDED'
        }
    });
}

export async function reverseJournal(id: string, userId?: string) {
    const original = await prisma.journalEntry.findUnique({
        where: { id },
        include: { lines: true }
    });

    if (!original) throw new Error("Journal not found");
    if (original.status !== 'POSTED') throw new Error("Only POSTED journals can be reversed");

    const reversalLines = original.lines.map(l => ({
        accountId: l.accountId,
        debit: Number(l.credit),
        credit: Number(l.debit),
        description: `Reversal of ${original.entryNumber}: ${l.description || ''} `
    }));

    return await createJournalEntry({
        entryDate: new Date(),
        description: `Reversal of ${original.description} `,
        reference: original.entryNumber,
        referenceType: 'MANUAL_ENTRY',
        createdById: userId,
        lines: reversalLines
    });
}

export async function createBulkJournalEntries(data: CreateJournalEntryInput[]) {
    const maxRetries = 3;
    let lastError: unknown;

    for (let i = 0; i < maxRetries; i++) {
        try {
            return await prisma.$transaction(async (tx) => {
                const results = [];
                for (const entry of data) {
                    const totalDebit = entry.lines.reduce((sum, l) => sum + (Number(l.debit) || 0), 0);
                    const totalCredit = entry.lines.reduce((sum, l) => sum + (Number(l.credit) || 0), 0);
                    if (Math.abs(totalDebit - totalCredit) > 0.01) {
                        throw new Error(`Unbalanced journal for reference ${entry.reference}`);
                    }

                    const entryNumber = await generateEntryNumber(entry.entryDate, tx);

                    const je = await tx.journalEntry.create({
                        data: {
                            entryNumber,
                            entryDate: entry.entryDate,
                            description: entry.description,
                            reference: entry.reference,
                            referenceType: entry.referenceType as ReferenceType,
                            createdById: entry.createdById,
                            isAutoGenerated: entry.isAutoGenerated,
                            status: entry.status || JournalStatus.DRAFT,
                            lines: {
                                create: entry.lines.map(l => ({
                                    accountId: l.accountId,
                                    debit: l.debit,
                                    credit: l.credit,
                                    description: l.description,
                                    currency: 'IDR',
                                    exchangeRate: 1
                                }))
                            }
                        }
                    });
                    results.push(je);
                }
                return results;
            }, {
                isolationLevel: Prisma.TransactionIsolationLevel.Serializable
            });
        } catch (error) {
            lastError = error;
            if (error instanceof Prisma.PrismaClientKnownRequestError &&
                (error.code === 'P2002' || error.code === 'P2034' || error.message.includes('serialization failure'))) {
                console.warn(`[JournalService] Bulk collision or serialization error, retrying... (${i + 1}/${maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, 100 * (i + 1)));
                continue;
            }
            throw error;
        }
    }
    throw lastError;
}

export async function getJournals(params?: { startDate?: Date, endDate?: Date, status?: JournalStatus, reference?: string }) {
    const where: Prisma.JournalEntryWhereInput = {};

    if (params?.startDate && params?.endDate) {
        where.entryDate = { gte: params.startDate, lte: params.endDate };
    }
    if (params?.status) {
        where.status = params.status;
    }
    if (params?.reference) {
        where.reference = { contains: params.reference, mode: 'insensitive' };
    }

    return await prisma.journalEntry.findMany({
        where,
        include: {
            createdBy: { select: { name: true } },
            lines: true
        },
        orderBy: { entryDate: 'desc' }
    });
}

export async function getJournalById(id: string) {
    return await prisma.journalEntry.findUnique({
        where: { id },
        include: {
            lines: {
                include: { account: true }
            },
            createdBy: { select: { name: true } },
            approvedBy: { select: { name: true } }
        }
    });
}

async function generateEntryNumber(date: Date, tx?: Prisma.TransactionClient): Promise<string> {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const db = (tx || prisma) as any;
    const year = date.getFullYear();
    const key = `JOURNAL_ENTRY_${year}`;

    try {
        // Try to increment existing sequence
        const sequence = await db.systemSequence.update({
            where: { key },
            data: { value: { increment: 1 } }
        });
        const currentVal = Number(sequence.value) - 1;
        return `JE - ${year} -${currentVal.toString().padStart(5, '0')}`;
    } catch (error) {
        // Record not found (P2025) means sequence hasn't been initialized for this year
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            const latestEntry = await (tx || prisma).journalEntry.findFirst({
                where: {
                    entryDate: {
                        gte: new Date(year, 0, 1),
                        lt: new Date(year + 1, 0, 1)
                    }
                },
                orderBy: { entryNumber: 'desc' }
            });

            let startValue = 1;
            if (latestEntry && latestEntry.entryNumber) {
                // JE - 2026 -00003
                const parts = latestEntry.entryNumber.split('-');
                const lastPart = parts[parts.length - 1].trim();
                const lastNum = parseInt(lastPart, 10);
                if (!isNaN(lastNum)) {
                    startValue = lastNum + 1;
                }
            }

            const sequence = await db.systemSequence.upsert({
                where: { key },
                update: { value: { increment: 1 } },
                create: { key, value: BigInt(startValue + 1) }
            });
            const currentVal = Number(sequence.value) - 1;
            return `JE - ${year} -${currentVal.toString().padStart(5, '0')}`;
        }
        throw error;
    }
}
