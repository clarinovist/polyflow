/* eslint-disable @typescript-eslint/no-require-imports */
/*
  Purge transactional history for Sales (SO), Purchasing (PO), and Production (WO).

  IMPORTANT:
  - Intended for production cutover / cleanup.
  - Keeps master data (products, BOM, inventory balances) intact.
  - Deletes dependent transactional docs (invoice, delivery, goods receipt, etc).

  Usage:
    # Dry-run (default)
    node scripts/purge-transaction-history.js

    # Execute (requires multiple confirmations)
    node scripts/purge-transaction-history.js --execute --yes --production

    # Also purge auto-generated finance journals that reference deleted docs
    node scripts/purge-transaction-history.js --execute --yes --production --purge-finance
*/

const { PrismaClient, ReferenceType, ReservationType } = require('@prisma/client');

function parseArgs(argv) {
  const flags = new Set(argv);
  return {
    execute: flags.has('--execute'),
    yes: flags.has('--yes'),
    production: flags.has('--production'),
    purgeFinance: flags.has('--purge-finance'),
    resetInventory: flags.has('--reset-inventory'),
    confirmResetInventory: flags.has('--confirm-reset-inventory'),
    confirmPurgeFinance: flags.has('--confirm-purge-finance'),
    iHaveABackup: flags.has('--i-have-a-backup'),
  };
}

function formatNumber(value) {
  const num = typeof value === 'number' ? value : Number(value);
  if (!Number.isFinite(num)) return String(value);
  return new Intl.NumberFormat('en-US').format(num);
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const prisma = new PrismaClient();

  try {
    const counts = {
      // Sales
      salesOrder: await prisma.salesOrder.count(),
      salesOrderItem: await prisma.salesOrderItem.count(),
      deliveryOrder: await prisma.deliveryOrder.count(),
      deliveryOrderItem: await prisma.deliveryOrderItem.count(),
      salesInvoice: await prisma.invoice.count(),
      salesStockMovement: await prisma.stockMovement.count({ where: { salesOrderId: { not: null } } }),
      salesReservations: await prisma.stockReservation.count({ where: { reservedFor: ReservationType.SALES_ORDER } }),

      // Purchasing
      purchaseOrder: await prisma.purchaseOrder.count(),
      purchaseOrderItem: await prisma.purchaseOrderItem.count(),
      goodsReceipt: await prisma.goodsReceipt.count(),
      goodsReceiptItem: await prisma.goodsReceiptItem.count(),
      purchaseInvoice: await prisma.purchaseInvoice.count(),
      purchasePayment: await prisma.purchasePayment.count(),
      receiptStockMovement: await prisma.stockMovement.count({ where: { goodsReceiptId: { not: null } } }),
      purchaseRequest: await prisma.purchaseRequest.count(),
      purchaseRequestItem: await prisma.purchaseRequestItem.count(),

      // Production (WO)
      productionOrder: await prisma.productionOrder.count(),
      productionShift: await prisma.productionShift.count(),
      productionExecution: await prisma.productionExecution.count(),
      productionMaterial: await prisma.productionMaterial.count(),
      materialIssue: await prisma.materialIssue.count(),
      scrapRecord: await prisma.scrapRecord.count(),
      qualityInspection: await prisma.qualityInspection.count(),
      productionIssue: await prisma.productionIssue.count(),
      productionReservations: await prisma.stockReservation.count({ where: { reservedFor: ReservationType.PRODUCTION_ORDER } }),

      // Inventory / Stock (optional)
      inventoryRows: await prisma.inventory.count(),
      batchRows: await prisma.batch.count(),

      // Finance (optional)
      autoJournalsReferencingDocs: await prisma.journalEntry.count({
        where: {
          isAutoGenerated: true,
          referenceType: {
            in: [
              ReferenceType.SALES_INVOICE,
              ReferenceType.SALES_PAYMENT,
              ReferenceType.PURCHASE_INVOICE,
              ReferenceType.PURCHASE_PAYMENT,
              ReferenceType.GOODS_RECEIPT,
              ReferenceType.PRODUCTION_OUTPUT,
              ReferenceType.MATERIAL_ISSUE,
            ],
          },
        },
      }),
    };

    console.log('=== Purge Transaction History (Dry-run by default) ===');
    console.log('Scope: delete SO/PO/WO history + dependent docs; keep master data (Inventory, Products, BOM).');
    console.log('');

    console.log('Sales');
    console.log(`- SalesOrder:         ${formatNumber(counts.salesOrder)}`);
    console.log(`- SalesOrderItem:     ${formatNumber(counts.salesOrderItem)}`);
    console.log(`- DeliveryOrder:      ${formatNumber(counts.deliveryOrder)}`);
    console.log(`- DeliveryOrderItem:  ${formatNumber(counts.deliveryOrderItem)}`);
    console.log(`- Invoice (sales):    ${formatNumber(counts.salesInvoice)}`);
    console.log(`- StockMovement (SO): ${formatNumber(counts.salesStockMovement)}`);
    console.log(`- StockReservation:   ${formatNumber(counts.salesReservations)}`);
    console.log('');

    console.log('Purchasing');
    console.log(`- PurchaseOrder:        ${formatNumber(counts.purchaseOrder)}`);
    console.log(`- PurchaseOrderItem:    ${formatNumber(counts.purchaseOrderItem)}`);
    console.log(`- GoodsReceipt:         ${formatNumber(counts.goodsReceipt)}`);
    console.log(`- GoodsReceiptItem:     ${formatNumber(counts.goodsReceiptItem)}`);
    console.log(`- PurchaseInvoice:      ${formatNumber(counts.purchaseInvoice)}`);
    console.log(`- PurchasePayment:      ${formatNumber(counts.purchasePayment)}`);
    console.log(`- StockMovement (GR):   ${formatNumber(counts.receiptStockMovement)}`);
    console.log(`- PurchaseRequest:      ${formatNumber(counts.purchaseRequest)}`);
    console.log(`- PurchaseRequestItem:  ${formatNumber(counts.purchaseRequestItem)}`);
    console.log('');

    console.log('Production (WO = ProductionOrder)');
    console.log(`- ProductionOrder:       ${formatNumber(counts.productionOrder)}`);
    console.log(`- ProductionShift:       ${formatNumber(counts.productionShift)}`);
    console.log(`- ProductionExecution:   ${formatNumber(counts.productionExecution)}`);
    console.log(`- ProductionMaterial:    ${formatNumber(counts.productionMaterial)}`);
    console.log(`- MaterialIssue:         ${formatNumber(counts.materialIssue)}`);
    console.log(`- ScrapRecord:           ${formatNumber(counts.scrapRecord)}`);
    console.log(`- QualityInspection:     ${formatNumber(counts.qualityInspection)}`);
    console.log(`- ProductionIssue:       ${formatNumber(counts.productionIssue)}`);
    console.log(`- StockReservation:      ${formatNumber(counts.productionReservations)}`);
    console.log('');

    console.log('Finance (optional)');
    console.log(`- Auto JournalEntry (referencing docs): ${formatNumber(counts.autoJournalsReferencingDocs)}`);
    console.log('');

    console.log('Stock (optional)');
    console.log(`- Inventory rows: ${formatNumber(counts.inventoryRows)}`);
    console.log(`- Batch rows:     ${formatNumber(counts.batchRows)}`);
    console.log(`- Reset inventory enabled: ${args.resetInventory ? 'YES' : 'NO'}`);
    console.log('');

    if (!args.execute) {
      console.log('Dry-run complete. To execute, re-run with: --execute --yes --production');
      console.log('Optional: add --purge-finance to delete auto-generated journals referencing deleted docs.');
      console.log('Optional: add --reset-inventory to set Inventory/Batch quantities to 0 (for fresh stock opname).');
      return;
    }

    if (!args.production) {
      throw new Error('Refusing to execute without --production flag (safety).');
    }

    if (!args.yes) {
      throw new Error('Refusing to execute without --yes flag (safety).');
    }

    if (!args.iHaveABackup) {
      throw new Error('Refusing to execute without --i-have-a-backup (safety). Create a pg_dump first.');
    }

    if (args.resetInventory && !args.confirmResetInventory) {
      throw new Error('Refusing to reset inventory without --confirm-reset-inventory (safety).');
    }

    if (args.purgeFinance && !args.confirmPurgeFinance) {
      throw new Error('Refusing to purge finance journals without --confirm-purge-finance (safety).');
    }

    console.log('Executing purge...');

    await prisma.$transaction(async (tx) => {
      if (args.purgeFinance) {
        await tx.journalEntry.deleteMany({
          where: {
            isAutoGenerated: true,
            referenceType: {
              in: [
                ReferenceType.SALES_INVOICE,
                ReferenceType.SALES_PAYMENT,
                ReferenceType.PURCHASE_INVOICE,
                ReferenceType.PURCHASE_PAYMENT,
                ReferenceType.GOODS_RECEIPT,
                ReferenceType.PRODUCTION_OUTPUT,
                ReferenceType.MATERIAL_ISSUE,
              ],
            },
          },
        });
      }

      // Remove cross-links early to avoid FK violations.
      await tx.productionOrder.updateMany({ where: { salesOrderId: { not: null } }, data: { salesOrderId: null } });
      await tx.productionOrder.updateMany({ where: { parentOrderId: { not: null } }, data: { parentOrderId: null } });
      await tx.purchaseRequest.updateMany({ where: { salesOrderId: { not: null } }, data: { salesOrderId: null } });
      await tx.purchaseRequest.updateMany({ where: { convertedToPoId: { not: null } }, data: { convertedToPoId: null } });

      // Clear operational stock traces (history)
      await tx.stockReservation.deleteMany({});
      await tx.stockMovement.deleteMany({});

      // Production (WO)
      await tx.productionExecution.deleteMany({});
      await tx.productionShift.deleteMany({});
      await tx.productionMaterial.deleteMany({});
      await tx.materialIssue.deleteMany({});
      await tx.scrapRecord.deleteMany({});
      await tx.qualityInspection.deleteMany({});
      await tx.productionIssue.deleteMany({});
      await tx.productionOrder.deleteMany({});

      // Sales
      await tx.deliveryOrderItem.deleteMany({});
      await tx.deliveryOrder.deleteMany({});
      await tx.invoice.deleteMany({});
      await tx.salesOrderItem.deleteMany({});
      await tx.salesOrder.deleteMany({});

      // Purchasing
      await tx.purchasePayment.deleteMany({});
      await tx.purchaseInvoice.deleteMany({});
      await tx.goodsReceiptItem.deleteMany({});
      await tx.goodsReceipt.deleteMany({});
      await tx.purchaseRequestItem.deleteMany({});
      await tx.purchaseRequest.deleteMany({});
      await tx.purchaseOrderItem.deleteMany({});
      await tx.purchaseOrder.deleteMany({});

      // Optional: reset balances for fresh stock opname
      if (args.resetInventory) {
        await tx.inventory.updateMany({ data: { quantity: 0, averageCost: null } });
        await tx.batch.updateMany({ data: { quantity: 0 } });
      }
    }, { timeout: 600_000 });

    console.log('Purge complete. Re-run without --execute to confirm counts are zero.');

    // Post-run verification (defensive): ensure transactional tables are empty.
    const post = {
      salesOrder: await prisma.salesOrder.count(),
      purchaseOrder: await prisma.purchaseOrder.count(),
      productionOrder: await prisma.productionOrder.count(),
      stockMovement: await prisma.stockMovement.count(),
      stockReservation: await prisma.stockReservation.count(),
      invoicesSales: await prisma.invoice.count(),
      invoicesPurchase: await prisma.purchaseInvoice.count(),
      goodsReceipt: await prisma.goodsReceipt.count(),
      autoJournals: await prisma.journalEntry.count({
        where: {
          isAutoGenerated: true,
          referenceType: {
            in: [
              ReferenceType.SALES_INVOICE,
              ReferenceType.SALES_PAYMENT,
              ReferenceType.PURCHASE_INVOICE,
              ReferenceType.PURCHASE_PAYMENT,
              ReferenceType.GOODS_RECEIPT,
              ReferenceType.PRODUCTION_OUTPUT,
              ReferenceType.MATERIAL_ISSUE,
            ],
          },
        },
      }),
      nonZeroInventory: args.resetInventory
        ? await prisma.inventory.count({ where: { quantity: { not: 0 } } })
        : null,
    };

    console.log('Post-run verification');
    console.log(`- SalesOrder:       ${formatNumber(post.salesOrder)}`);
    console.log(`- PurchaseOrder:    ${formatNumber(post.purchaseOrder)}`);
    console.log(`- ProductionOrder:  ${formatNumber(post.productionOrder)}`);
    console.log(`- StockMovement:    ${formatNumber(post.stockMovement)}`);
    console.log(`- StockReservation: ${formatNumber(post.stockReservation)}`);
    console.log(`- Sales Invoice:    ${formatNumber(post.invoicesSales)}`);
    console.log(`- Purchase Invoice: ${formatNumber(post.invoicesPurchase)}`);
    console.log(`- GoodsReceipt:     ${formatNumber(post.goodsReceipt)}`);
    console.log(`- Auto Journals:    ${formatNumber(post.autoJournals)}`);
    if (args.resetInventory) {
      console.log(`- Inventory non-zero rows: ${formatNumber(post.nonZeroInventory)}`);
    }

    const failures = [];
    if (post.salesOrder !== 0) failures.push('SalesOrder not empty');
    if (post.purchaseOrder !== 0) failures.push('PurchaseOrder not empty');
    if (post.productionOrder !== 0) failures.push('ProductionOrder not empty');
    if (post.stockMovement !== 0) failures.push('StockMovement not empty');
    if (post.stockReservation !== 0) failures.push('StockReservation not empty');
    if (post.invoicesSales !== 0) failures.push('Sales invoices not empty');
    if (post.invoicesPurchase !== 0) failures.push('Purchase invoices not empty');
    if (post.goodsReceipt !== 0) failures.push('GoodsReceipt not empty');
    if (args.purgeFinance && post.autoJournals !== 0) failures.push('Auto journals not empty');
    if (args.resetInventory && post.nonZeroInventory !== 0) failures.push('Inventory not fully reset to 0');

    if (failures.length > 0) {
      throw new Error(`Post-run verification failed: ${failures.join('; ')}`);
    }
  } finally {
    await prisma.$disconnect();
  }
}

main().catch((err) => {
  console.error('\nERROR:', err instanceof Error ? err.message : err);
  process.exitCode = 1;
});
